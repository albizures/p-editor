/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("const GIFEncoder = __webpack_require__(1);\n\nlet renderFrame = function (frame) {\n\tvar encoder, page, stream, transfer;\n\tencoder = new GIFEncoder(frame.width, frame.height);\n\tif (frame.index === 0) {\n\t\tencoder.writeHeader();\n\t} else {\n\t\tencoder.firstFrame = false;\n\t}\n\tconsole.log(frame.transparent);\n\tencoder.setTransparent(frame.transparent);\n\tencoder.setRepeat(frame.repeat);\n\tencoder.setDelay(frame.delay);\n\tencoder.setQuality(frame.quality);\n\tencoder.setPreserveColors(frame.preserveColors);\n\tencoder.addFrame(frame.data);\n\tif (frame.last) {\n\t\tencoder.finish();\n\t}\n\tif (frame.globalPalette === true) {\n\t\tframe.globalPalette = encoder.getGlobalPalette();\n\t}\n\tstream = encoder.stream();\n\tframe.data = stream.pages;\n\tframe.cursor = stream.cursor;\n\tframe.pageSize = stream.constructor.pageSize;\n\tif (frame.canTransfer) {\n\t\ttransfer = (function () {\n\t\t\tvar i, len, ref, results;\n\t\t\tref = frame.data;\n\t\t\tresults = [];\n\t\t\tfor (i = 0, len = ref.length; i < len; i++) {\n\t\t\t\tpage = ref[i];\n\t\t\t\tresults.push(page.buffer);\n\t\t\t}\n\t\t\treturn results;\n\t\t})();\n\t\treturn self.postMessage(frame, transfer);\n\t} else {\n\t\treturn self.postMessage(frame);\n\t}\n};\n\nself.onmessage = function (event) {\n\treturn renderFrame(event.data);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eslint-loader!./~/jscs-loader!./src/client/workers/gif.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/client/workers/gif.js?./~/eslint-loader!./~/jscs-loader");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/*\n  GIFEncoder.js\n\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n*/\n\nvar NeuQuant = __webpack_require__(2),\n    SimpleQuant = __webpack_require__(3),\n    LZWEncoder = __webpack_require__(4);\n\nfunction ByteArray() {\n\tthis.page = -1;\n\tthis.pages = [];\n\tthis.newPage();\n}\n\nByteArray.pageSize = 4096;\nByteArray.charMap = {};\n\nfor (var i = 0; i < 256; i++) {\n\tByteArray.charMap[i] = String.fromCharCode(i);\n}\nByteArray.prototype.newPage = function () {\n\tthis.pages[++this.page] = new Uint8Array(ByteArray.pageSize);\n\tthis.cursor = 0;\n};\n\nByteArray.prototype.getData = function () {\n\tvar rv = '';\n\tfor (var p = 0; p < this.pages.length; p++) {\n\t\tfor (var _i = 0; _i < ByteArray.pageSize; _i++) {\n\t\t\trv += ByteArray.charMap[this.pages[p][_i]];\n\t\t}\n\t}\n\treturn rv;\n};\n\nByteArray.prototype.writeByte = function (val) {\n\tif (this.cursor >= ByteArray.pageSize) {\n\t\tthis.newPage();\n\t}\n\tthis.pages[this.page][this.cursor++] = val;\n};\n\nByteArray.prototype.writeUTFBytes = function (string) {\n\tfor (var l = string.length, _i2 = 0; _i2 < l; _i2++) {\n\t\tthis.writeByte(string.charCodeAt(_i2));\n\t}\n};\n\nByteArray.prototype.writeBytes = function (array, offset, length) {\n\tfor (var l = length || array.length, _i3 = offset || 0; _i3 < l; _i3++) {\n\t\tthis.writeByte(array[_i3]);\n\t}\n};\n\nfunction GIFEncoder(width, height) {\n\t// image size\n\tthis.width = ~ ~width;\n\tthis.height = ~ ~height;\n\n\t// transparent color if given\n\tthis.transparent = null;\n\n\t// transparent index in color table\n\tthis.transIndex = 0;\n\n\t// -1 = no repeat, 0 = forever. anything else is repeat count\n\tthis.repeat = -1;\n\n\t// frame delay (hundredths)\n\tthis.delay = 0;\n\n\tthis.image = null; // current frame\n\tthis.pixels = null; // BGR byte array from frame\n\tthis.indexedPixels = null; // converted frame indexed to palette\n\tthis.colorDepth = null; // number of bit planes\n\tthis.colorTab = null; // RGB palette\n\tthis.usedEntry = new Array(); // active palette entries\n\tthis.palSize = 7; // color table size (bits-1)\n\tthis.dispose = -1; // disposal code (-1 = use default)\n\tthis.firstFrame = true;\n\tthis.sample = 10; // default sample interval for quantizer\n\n\tthis.out = new ByteArray();\n}\n\n/*\n  Sets the delay time between each frame, or changes it for subsequent frames\n  (applies to last frame added)\n*/\nGIFEncoder.prototype.setDelay = function (milliseconds) {\n\tthis.delay = Math.round(milliseconds / 10);\n};\n\n/*\n  Sets frame rate in frames per second.\n*/\nGIFEncoder.prototype.setFrameRate = function (fps) {\n\tthis.delay = Math.round(100 / fps);\n};\n/*\n  Sets the GIF frame disposal code for the last added frame and any\n  subsequent frames.\n\n  Default is 0 if no transparent color has been set, otherwise 2.\n*/\nGIFEncoder.prototype.setDispose = function (disposalCode) {\n\tif (disposalCode >= 0) {\n\t\tthis.dispose = disposalCode;\n\t}\n};\n\n/*\n  Sets the number of times the set of GIF frames should be played.\n\n  -1 = play once\n  0 = repeat indefinitely\n\n  Default is -1\n\n  Must be invoked before the first image is added\n*/\n\nGIFEncoder.prototype.setRepeat = function (repeat) {\n\tthis.repeat = repeat;\n};\n\n/*\n  Sets the transparent color for the last added frame and any subsequent\n  frames. Since all colors are subject to modification in the quantization\n  process, the color in the final palette for each frame closest to the given\n  color becomes the transparent color for that frame. May be set to null to\n  indicate no transparent color.\n*/\nGIFEncoder.prototype.setTransparent = function (color) {\n\tthis.transparent = color;\n};\n\n/*\n  Sets a flag that will force to use the SimpleQuant (less than 256 colors)\n*/\nGIFEncoder.prototype.setPreserveColors = function (preserveColors) {\n\tthis.preserveColors = preserveColors;\n};\n\n/*\n  Adds next GIF frame. The frame is not written immediately, but is\n  actually deferred until the next frame is received so that timing\n  data can be inserted.  Invoking finish() flushes all frames.\n*/\nGIFEncoder.prototype.addFrame = function (imageData) {\n\tthis.image = imageData;\n\n\tthis.getImagePixels(); // convert to correct format if necessary\n\tthis.analyzePixels(); // build color table & map pixels\n\n\tif (this.firstFrame) {\n\t\tthis.writeLSD(); // logical screen descriptior\n\t\tthis.writePalette(); // global color table\n\t\tif (this.repeat >= 0) {\n\t\t\t// use NS app extension to indicate reps\n\t\t\tthis.writeNetscapeExt();\n\t\t}\n\t}\n\n\tthis.writeGraphicCtrlExt(); // write graphic control extension\n\tthis.writeImageDesc(); // image descriptor\n\tif (!this.firstFrame) {\n\t\tthis.writePalette(); // local color table\n\t}\n\tthis.writePixels(); // encode and write pixel data\n\n\tthis.firstFrame = false;\n};\n\n/*\n  Adds final trailer to the GIF stream, if you don't call the finish method\n  the GIF stream will not be valid.\n*/\nGIFEncoder.prototype.finish = function () {\n\tthis.out.writeByte(0x3b); // gif trailer\n};\n\n/*\n  Sets quality of color quantization (conversion of images to the maximum 256\n  colors allowed by the GIF specification). Lower values (minimum = 1)\n  produce better colors, but slow processing significantly. 10 is the\n  default, and produces good color mapping at reasonable speeds. Values\n  greater than 20 do not yield significant improvements in speed.\n*/\nGIFEncoder.prototype.setQuality = function (quality) {\n\tif (quality < 1) {\n\t\tquality = 1;\n\t}\n\tthis.sample = quality;\n};\n\n/*\n  Writes GIF file header\n*/\nGIFEncoder.prototype.writeHeader = function () {\n\tthis.out.writeUTFBytes(\"GIF89a\");\n};\n/*\n  Analyzes current frame colors and creates color map.\n*/\n\nGIFEncoder.prototype.analyzePixels = function () {\n\tvar imgq,\n\t    len = this.pixels.length,\n\t    nPix = len / 3,\n\t    k = 0;\n\tthis.indexedPixels = new Uint8Array(nPix);\n\tif (this.preserveColors) {\n\t\tvar transparentComponents = this.toRGBComponents(this.transparent);\n\t\timgq = new SimpleQuant(this.pixels, this.sample, transparentComponents); //new NeuQuant(this.pixels, this.sample);\n\t} else {\n\t\t\timgq = new NeuQuant(this.pixels, this.sample);\n\t\t}\n\timgq.buildColormap(); // create reduced palette\n\tthis.colorTab = imgq.getColormap();\n\t// map image pixels to new palette\n\tfor (var j = 0; j < nPix; j++) {\n\t\tvar index = imgq.lookupRGB(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);\n\t\tthis.usedEntry[index] = true;\n\t\tthis.indexedPixels[j] = index;\n\t}\n\n\tthis.pixels = null;\n\tthis.colorDepth = 8;\n\tthis.palSize = 7;\n\t// get closest match to transparent color if specified\n\tif (this.transparent !== null) {\n\t\tthis.transIndex = this.findClosest(this.transparent, true);\n\t}\n};\nGIFEncoder.prototype.toRGBComponents = function (color) {\n\tvar components = null;\n\tif (color) {\n\t\tcomponents = {\n\t\t\tr: (color & 16711680) >> 16,\n\t\t\tg: (color & 65280) >> 8,\n\t\t\tb: color & 255\n\t\t};\n\t}\n\treturn components;\n};\n\n/*\n  Index pixels, without dithering\n*/\nGIFEncoder.prototype.indexPixels = function (imgq) {\n\tvar nPix = this.pixels.length / 3,\n\t    k = 0;\n\tthis.indexedPixels = new Uint8Array(nPix);\n\tfor (var j = 0; j < nPix; j++) {\n\t\tvar index = this.findClosestRGB(this.pixels[k++] & 0xff, this.pixels[k++] & 0xff, this.pixels[k++] & 0xff);\n\t\tthis.usedEntry[index] = true;\n\t\tthis.indexedPixels[j] = index;\n\t}\n};\n/*\n  Returns index of palette color closest to c\n*/\nGIFEncoder.prototype.findClosest = function (c) {\n\tvar r = (c & 0xFF0000) >> 16,\n\t    g = (c & 0x00FF00) >> 8,\n\t    b = c & 0x0000FF,\n\t    minpos = 0,\n\t    dmin = 256 * 256 * 256,\n\t    len = this.colorTab.length;\n\tif (this.colorTab === null) {\n\t\treturn -1;\n\t}\n\n\tfor (var _i4 = 0; _i4 < len;) {\n\t\tvar dr = r - (this.colorTab[_i4++] & 0xff),\n\t\t    dg = g - (this.colorTab[_i4++] & 0xff),\n\t\t    db = b - (this.colorTab[_i4] & 0xff),\n\t\t    d = dr * dr + dg * dg + db * db,\n\t\t    index = parseInt(_i4 / 3),\n\t\t    isIndexValid = this.preserveColors || this.usedEntry[index];\n\t\tif (isIndexValid && d < dmin) {\n\t\t\tdmin = d;\n\t\t\tminpos = index;\n\t\t}\n\t\t_i4++;\n\t}\n\n\treturn minpos;\n};\n\n/*\n  Extracts image pixels into byte array pixels\n  (removes alphachannel from canvas imagedata)\n*/\nGIFEncoder.prototype.getImagePixels = function () {\n\tvar w = this.width,\n\t    h = this.height,\n\t    data = this.image,\n\t    count = 0;\n\tthis.pixels = new Uint8Array(w * h * 3);\n\n\tfor (var _i5 = 0; _i5 < h; _i5++) {\n\t\tfor (var j = 0; j < w; j++) {\n\t\t\tvar b = _i5 * w * 4 + j * 4;\n\t\t\tthis.pixels[count++] = data[b];\n\t\t\tthis.pixels[count++] = data[b + 1];\n\t\t\tthis.pixels[count++] = data[b + 2];\n\t\t}\n\t}\n};\n\n/*\n  Writes Graphic Control Extension\n*/\nGIFEncoder.prototype.writeGraphicCtrlExt = function () {\n\tthis.out.writeByte(0x21); // extension introducer\n\tthis.out.writeByte(0xf9); // GCE label\n\tthis.out.writeByte(4); // data block size\n\n\tvar transp = void 0,\n\t    disp = void 0;\n\tif (this.transparent === null) {\n\t\ttransp = 0;\n\t\tdisp = 0; // dispose = no action\n\t} else {\n\t\t\ttransp = 1;\n\t\t\tdisp = 2; // force clear if using transparent color\n\t\t}\n\n\tif (this.dispose >= 0) {\n\t\tdisp = dispose & 7; // user override\n\t}\n\tdisp <<= 2;\n\n\t// packed fields\n\tthis.out.writeByte(0 | // 1:3 reserved\n\tdisp | // 4:6 disposal\n\t0 | // 7 user input - 0 = none\n\ttransp // 8 transparency flag\n\t);\n\n\tthis.writeShort(this.delay); // delay x 1/100 sec\n\tthis.out.writeByte(this.transIndex); // transparent color index\n\tthis.out.writeByte(0); // block terminator\n};\n\n/*\n  Writes Image Descriptor\n*/\nGIFEncoder.prototype.writeImageDesc = function () {\n\tthis.out.writeByte(0x2c); // image separator\n\tthis.writeShort(0); // image position x,y = 0,0\n\tthis.writeShort(0);\n\tthis.writeShort(this.width); // image size\n\tthis.writeShort(this.height);\n\n\t// packed fields\n\tif (this.firstFrame) {\n\t\t// no LCT - GCT is used for first (or only) frame\n\t\tthis.out.writeByte(0);\n\t} else {\n\t\t// specify normal LCT\n\t\tthis.out.writeByte(0x80 | // 1 local color table 1=yes\n\t\t0 | // 2 interlace - 0=no\n\t\t0 | // 3 sorted - 0=no\n\t\t0 | // 4-5 reserved\n\t\tthis.palSize // 6-8 size of color table\n\t\t);\n\t}\n};\n\n/*\n  Writes Logical Screen Descriptor\n*/\nGIFEncoder.prototype.writeLSD = function () {\n\t// logical screen size\n\tthis.writeShort(this.width);\n\tthis.writeShort(this.height);\n\n\t// packed fields\n\tthis.out.writeByte(0x80 | // 1 : global color table flag = 1 (gct used)\n\t0x70 | // 2-4 : color resolution = 7\n\t0x00 | // 5 : gct sort flag = 0\n\tthis.palSize // 6-8 : gct size\n\t);\n\n\tthis.out.writeByte(0); // background color index\n\tthis.out.writeByte(0); // pixel aspect ratio - assume 1:1\n};\n\n/*\n  Writes Netscape application extension to define repeat count.\n*/\nGIFEncoder.prototype.writeNetscapeExt = function () {\n\tthis.out.writeByte(0x21); // extension introducer\n\tthis.out.writeByte(0xff); // app extension label\n\tthis.out.writeByte(11); // block size\n\tthis.out.writeUTFBytes('NETSCAPE2.0'); // app id + auth code\n\tthis.out.writeByte(3); // sub-block size\n\tthis.out.writeByte(1); // loop sub-block id\n\tthis.writeShort(this.repeat); // loop count (extra iterations, 0=repeat forever)\n\tthis.out.writeByte(0); // block terminator\n};\n\n/*\n  Writes color table\n*/\nGIFEncoder.prototype.writePalette = function () {\n\tthis.out.writeBytes(this.colorTab);\n\tvar n = 3 * 256 - this.colorTab.length;\n\tfor (var _i6 = 0; _i6 < n; _i6++) {\n\t\tthis.out.writeByte(0);\n\t}\n};\n\nGIFEncoder.prototype.writeShort = function (pValue) {\n\tthis.out.writeByte(pValue & 0xFF);\n\tthis.out.writeByte(pValue >> 8 & 0xFF);\n};\n\n/*\n  Encodes and writes pixel data\n*/\nGIFEncoder.prototype.writePixels = function () {\n\tvar enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);\n\tenc.encode(this.out);\n};\n\n/*\n  Retrieves the GIF stream\n*/\nGIFEncoder.prototype.stream = function () {\n\treturn this.out;\n};\n\nmodule.exports = GIFEncoder;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/prototypes/gif/GIFEncoder.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/client/prototypes/gif/GIFEncoder.js?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/* \tNeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n */\n\nvar ncycles = 100,\n    // number of learning cycles\nnetsize = 256,\n    // number of colors used\nmaxnetpos = netsize - 1,\n\n\n// defs for freq and bias\nnetbiasshift = 4,\n    // bias for colour values\nintbiasshift = 16,\n    // bias for fractions\nintbias = 1 << intbiasshift,\n    gammashift = 10,\n    gamma = 1 << gammashift,\n    betashift = 10,\n    beta = intbias >> betashift,\n\n/* beta = 1/1024 */\nbetagamma = intbias << gammashift - betashift,\n\n\n// defs for decreasing radius factor\ninitrad = netsize >> 3,\n    // for 256 cols, radius starts\nradiusbiasshift = 6,\n    // at 32.0 biased by 6 bits\nradiusbias = 1 << radiusbiasshift,\n    initradius = initrad * radiusbias,\n    //and decreases by a\nradiusdec = 30,\n    // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nalphabiasshift = 10,\n    // alpha starts at 1.0\ninitalpha = 1 << alphabiasshift,\n    alphadec,\n    // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nradbiasshift = 8,\n    radbias = 1 << radbiasshift,\n    alpharadbshift = alphabiasshift + radbiasshift,\n    alpharadbias = 1 << alpharadbshift,\n\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nprime1 = 499,\n    prime2 = 491,\n    prime3 = 487,\n    prime4 = 503,\n    minpicturebytes = 3 * prime4;\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac) {\n\tvar network = void 0,\n\t    // int[netsize][4]\n\tnetindex = void 0,\n\t    // for network lookup - really 256\n\n\t// bias and freq arrays for learning\n\tbias = void 0,\n\t    freq = void 0,\n\t    radpower = void 0;\n\n\t/*\n   Private Method: init\n \t  sets up arrays\n */\n\tfunction init() {\n\t\tnetwork = [];\n\t\tnetindex = new Int32Array(256);\n\t\tbias = new Int32Array(netsize);\n\t\tfreq = new Int32Array(netsize);\n\t\tradpower = new Int32Array(netsize >> 3);\n\n\t\tvar i = void 0,\n\t\t    v = void 0;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tv = (i << netbiasshift + 8) / netsize;\n\t\t\tnetwork[i] = new Float64Array([v, v, v, 0]);\n\t\t\t//network[i] = [v, v, v, 0]\n\t\t\tfreq[i] = intbias / netsize;\n\t\t\tbias[i] = 0;\n\t\t}\n\t}\n\n\t/*\n   Private Method: unbiasnet\n \t  unbiases network to give byte values 0..255 and record position i to prepare for sort\n */\n\tfunction unbiasnet() {\n\t\tfor (var i = 0; i < netsize; i++) {\n\t\t\tnetwork[i][0] >>= netbiasshift;\n\t\t\tnetwork[i][1] >>= netbiasshift;\n\t\t\tnetwork[i][2] >>= netbiasshift;\n\t\t\tnetwork[i][3] = i; // record color number\n\t\t}\n\t}\n\n\t/*\n   Private Method: altersingle\n \t  moves neuron *i* towards biased (b,g,r) by factor *alpha*\n */\n\tfunction altersingle(alpha, i, b, g, r) {\n\t\tnetwork[i][0] -= alpha * (network[i][0] - b) / initalpha;\n\t\tnetwork[i][1] -= alpha * (network[i][1] - g) / initalpha;\n\t\tnetwork[i][2] -= alpha * (network[i][2] - r) / initalpha;\n\t}\n\n\t/*\n   Private Method: alterneigh\n \t  moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n */\n\tfunction alterneigh(radius, i, b, g, r) {\n\t\tvar lo = Math.abs(i - radius),\n\t\t    hi = Math.min(i + radius, netsize),\n\t\t    j = i + 1,\n\t\t    k = i - 1,\n\t\t    m = 1,\n\t\t    p,\n\t\t    a;\n\t\twhile (j < hi || k > lo) {\n\t\t\ta = radpower[m++];\n\n\t\t\tif (j < hi) {\n\t\t\t\tp = network[j++];\n\t\t\t\tp[0] -= a * (p[0] - b) / alpharadbias;\n\t\t\t\tp[1] -= a * (p[1] - g) / alpharadbias;\n\t\t\t\tp[2] -= a * (p[2] - r) / alpharadbias;\n\t\t\t}\n\n\t\t\tif (k > lo) {\n\t\t\t\tp = network[k--];\n\t\t\t\tp[0] -= a * (p[0] - b) / alpharadbias;\n\t\t\t\tp[1] -= a * (p[1] - g) / alpharadbias;\n\t\t\t\tp[2] -= a * (p[2] - r) / alpharadbias;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n   Private Method: contest\n \t  searches for biased BGR values\n */\n\tfunction contest(b, g, r) {\n\t\t/*\n    finds closest neuron (min dist) and updates freq\n    finds best neuron (min dist-bias) and returns position\n    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n    bias[i] = gamma * ((1 / netsize) - freq[i])\n  */\n\n\t\tvar bestd = ~(1 << 31),\n\t\t    bestbiasd = bestd,\n\t\t    bestpos = -1,\n\t\t    bestbiaspos = bestpos,\n\t\t    i,\n\t\t    n,\n\t\t    dist,\n\t\t    biasdist,\n\t\t    betafreq;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tn = network[i];\n\n\t\t\tdist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);\n\t\t\tif (dist < bestd) {\n\t\t\t\tbestd = dist;\n\t\t\t\tbestpos = i;\n\t\t\t}\n\n\t\t\tbiasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\n\t\t\tif (biasdist < bestbiasd) {\n\t\t\t\tbestbiasd = biasdist;\n\t\t\t\tbestbiaspos = i;\n\t\t\t}\n\n\t\t\tbetafreq = freq[i] >> betashift;\n\t\t\tfreq[i] -= betafreq;\n\t\t\tbias[i] += betafreq << gammashift;\n\t\t}\n\n\t\tfreq[bestpos] += beta;\n\t\tbias[bestpos] -= betagamma;\n\n\t\treturn bestbiaspos;\n\t}\n\n\t/*\n   Private Method: inxbuild\n \t  sorts network and builds netindex[0..255]\n */\n\tfunction inxbuild() {\n\t\tvar i,\n\t\t    j,\n\t\t    p,\n\t\t    q,\n\t\t    smallpos,\n\t\t    smallval,\n\t\t    previouscol = 0,\n\t\t    startpos = 0;\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tp = network[i];\n\t\t\tsmallpos = i;\n\t\t\tsmallval = p[1]; // index on g\n\t\t\t// find smallest in i..netsize-1\n\t\t\tfor (j = i + 1; j < netsize; j++) {\n\t\t\t\tq = network[j];\n\t\t\t\tif (q[1] < smallval) {\n\t\t\t\t\t// index on g\n\t\t\t\t\tsmallpos = j;\n\t\t\t\t\tsmallval = q[1]; // index on g\n\t\t\t\t}\n\t\t\t}\n\t\t\tq = network[smallpos];\n\t\t\t// swap p (i) and q (smallpos) entries\n\t\t\tif (i != smallpos) {\n\t\t\t\tj = q[0];\n\t\t\t\tq[0] = p[0];\n\t\t\t\tp[0] = j;\n\t\t\t\tj = q[1];\n\t\t\t\tq[1] = p[1];\n\t\t\t\tp[1] = j;\n\t\t\t\tj = q[2];\n\t\t\t\tq[2] = p[2];\n\t\t\t\tp[2] = j;\n\t\t\t\tj = q[3];\n\t\t\t\tq[3] = p[3];\n\t\t\t\tp[3] = j;\n\t\t\t}\n\t\t\t// smallval entry is now in position i\n\n\t\t\tif (smallval != previouscol) {\n\t\t\t\tnetindex[previouscol] = startpos + i >> 1;\n\t\t\t\tfor (j = previouscol + 1; j < smallval; j++) {\n\t\t\t\t\tnetindex[j] = i;\n\t\t\t\t}\n\t\t\t\tpreviouscol = smallval;\n\t\t\t\tstartpos = i;\n\t\t\t}\n\t\t}\n\t\tnetindex[previouscol] = startpos + maxnetpos >> 1;\n\t\tfor (j = previouscol + 1; j < 256; j++) {\n\t\t\tnetindex[j] = maxnetpos; // really 256\n\t\t}\n\t}\n\n\t/*\n   Private Method: inxsearch\n \t  searches for BGR values 0..255 and returns a color index\n */\n\tfunction inxsearch(b, g, r) {\n\t\tvar a,\n\t\t    p,\n\t\t    dist,\n\t\t    bestd = 1000,\n\t\t    // biggest possible dist is 256*3\n\t\tbest = -1,\n\t\t    i = netindex[g],\n\t\t    // index on g\n\t\tj = i - 1; // start at netindex[g] and work outwards\n\n\t\twhile (i < netsize || j >= 0) {\n\t\t\tif (i < netsize) {\n\t\t\t\tp = network[i];\n\t\t\t\tdist = p[1] - g; // inx key\n\t\t\t\tif (dist >= bestd) {\n\t\t\t\t\ti = netsize; // stop iter\n\t\t\t\t} else {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tif (dist < 0) {\n\t\t\t\t\t\t\tdist = -dist;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = p[0] - b;\n\t\t\t\t\t\tif (a < 0) {\n\t\t\t\t\t\t\ta = -a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\ta = p[2] - r;\n\t\t\t\t\t\t\tif (a < 0) {\n\t\t\t\t\t\t\t\ta = -a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\t\tbestd = dist;\n\t\t\t\t\t\t\t\tbest = p[3];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tp = network[j];\n\t\t\t\tdist = g - p[1]; // inx key - reverse dif\n\t\t\t\tif (dist >= bestd) {\n\t\t\t\t\tj = -1; // stop iter\n\t\t\t\t} else {\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tif (dist < 0) {\n\t\t\t\t\t\t\tdist = -dist;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta = p[0] - b;\n\t\t\t\t\t\tif (a < 0) {\n\t\t\t\t\t\t\ta = -a;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\ta = p[2] - r;\n\t\t\t\t\t\t\tif (a < 0) {\n\t\t\t\t\t\t\t\ta = -a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist += a;\n\t\t\t\t\t\t\tif (dist < bestd) {\n\t\t\t\t\t\t\t\tbestd = dist;\n\t\t\t\t\t\t\t\tbest = p[3];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn best;\n\t}\n\n\t/*\n   Private Method: learn\n \t  \"Main Learning Loop\"\n */\n\tfunction learn() {\n\t\tvar i,\n\t\t    lengthcount = pixels.length,\n\t\t    alphadec = 30 + (samplefac - 1) / 3,\n\t\t    samplepixels = lengthcount / (3 * samplefac),\n\t\t    delta = ~ ~(samplepixels / ncycles),\n\t\t    alpha = initalpha,\n\t\t    radius = initradius,\n\t\t    rad = radius >> radiusbiasshift;\n\n\t\tif (rad <= 1) {\n\t\t\trad = 0;\n\t\t}\n\t\tfor (i = 0; i < rad; i++) {\n\t\t\tradpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\n\t\t}\n\t\tvar step = void 0;\n\t\tif (lengthcount < minpicturebytes) {\n\t\t\tsamplefac = 1;\n\t\t\tstep = 3;\n\t\t} else if (lengthcount % prime1 !== 0) {\n\t\t\tstep = 3 * prime1;\n\t\t} else if (lengthcount % prime2 !== 0) {\n\t\t\tstep = 3 * prime2;\n\t\t} else if (lengthcount % prime3 !== 0) {\n\t\t\tstep = 3 * prime3;\n\t\t} else {\n\t\t\tstep = 3 * prime4;\n\t\t}\n\n\t\tvar b = void 0,\n\t\t    g = void 0,\n\t\t    r = void 0,\n\t\t    j = void 0,\n\t\t    pix = 0; // current pixel\n\n\t\ti = 0;\n\t\twhile (i < samplepixels) {\n\t\t\tb = (pixels[pix] & 0xff) << netbiasshift;\n\t\t\tg = (pixels[pix + 1] & 0xff) << netbiasshift;\n\t\t\tr = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n\t\t\tj = contest(b, g, r);\n\n\t\t\taltersingle(alpha, j, b, g, r);\n\t\t\tif (rad !== 0) {\n\t\t\t\talterneigh(rad, j, b, g, r); // alter neighbours\n\t\t\t}\n\n\t\t\tpix += step;\n\t\t\tif (pix >= lengthcount) {\n\t\t\t\tpix -= lengthcount;\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t\tif (delta === 0) {\n\t\t\t\tdelta = 1;\n\t\t\t}\n\t\t\tif (i % delta === 0) {\n\t\t\t\talpha -= alpha / alphadec;\n\t\t\t\tradius -= radius / radiusdec;\n\t\t\t\trad = radius >> radiusbiasshift;\n\n\t\t\t\tif (rad <= 1) {\n\t\t\t\t\trad = 0;\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < rad; j++) {\n\t\t\t\t\tradpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n   Method: buildColormap\n \t  1. initializes network\n   2. trains it\n   3. removes misconceptions\n   4. builds colorindex\n */\n\tfunction buildColormap() {\n\t\tinit();\n\t\tlearn();\n\t\tunbiasnet();\n\t\tinxbuild();\n\t}\n\tthis.buildColormap = buildColormap;\n\n\t/*\n   Method: getColormap\n \t  builds colormap from the index\n \t  returns array in the format:\n \t  >\n   > [r, g, b, r, g, b, r, g, b, ..]\n   >\n */\n\tfunction getColormap() {\n\t\tvar map = [],\n\t\t    index = [],\n\t\t    k = 0,\n\t\t    i,\n\t\t    l;\n\n\t\tfor (i = 0; i < netsize; i++) {\n\t\t\tindex[network[i][3]] = i;\n\t\t}\n\n\t\tfor (l = 0; l < netsize; l++) {\n\t\t\tvar j = index[l];\n\t\t\tmap[k++] = network[j][0];\n\t\t\tmap[k++] = network[j][1];\n\t\t\tmap[k++] = network[j][2];\n\t\t}\n\t\treturn map;\n\t}\n\tthis.getColormap = getColormap;\n\n\t/*\n   Method: lookupRGB\n \t  looks for the closest *r*, *g*, *b* color in the map and\n   returns its index\n */\n\tthis.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/libs/gif/TypedNeuQuant.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/client/libs/gif/TypedNeuQuant.js?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("'use strict';\n\n/*\n\tJulian Descottes (origianl version - https://github.com/juliandescottes/gif.js)\n*/\n\nfunction getPaletteKey(r, g, b) {\n\treturn [r, g, b].join('.');\n}\n\nfunction SimpleQuant(pixels, sample, transparent) {\n\tthis.pixels = pixels;\n\tthis.palette = [];\n\tthis.paletteIndex = {};\n\tthis.transparent = transparent;\n\tconsole.info(this.transparent);\n}\nSimpleQuant.prototype.getColormap = function () {\n\treturn this.palette;\n};\nSimpleQuant.prototype.buildColormap = function () {\n\tvar npixels = this.pixels.length / 3,\n\t    k = 0;\n\tfor (var i = 0; i < npixels; i++) {\n\t\tvar r = this.pixels[k++],\n\t\t    g = this.pixels[k++],\n\t\t    b = this.pixels[k++];\n\t\tthis.addColorToPalette(r, g, b);\n\t}\n\n\tif (this.transparent) {\n\t\tthis.addColorToPalette(this.transparent.r, this.transparent.g, this.transparent.b);\n\t}\n};\n\nSimpleQuant.prototype.addColorToPalette = function (r, g, b) {\n\tvar key = getPaletteKey(r, g, b);\n\tif (!this.paletteIndex.hasOwnProperty(key)) {\n\t\tthis.palette.push(r);\n\t\tthis.palette.push(g);\n\t\tthis.palette.push(b);\n\t\tthis.paletteIndex[key] = this.palette.length / 3 - 1;\n\t}\n};\n\nSimpleQuant.prototype.lookupRGB = function (r, g, b) {\n\treturn this.paletteIndex[getPaletteKey(r, g, b)];\n};\n\nmodule.exports = SimpleQuant;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/prototypes/gif/SimpleQuant.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/client/prototypes/gif/SimpleQuant.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/*\n  LZWEncoder.js\n\n  Authors\n  Kevin Weiner (original Java version - kweiner@fmsware.com)\n  Thibault Imbert (AS3 version - bytearray.org)\n  Johan Nordberg (JS version - code@johan-nordberg.com)\n\n  Acknowledgements\n  GIFCOMPR.C - GIF Image compression routines\n  Lempel-Ziv compression based on 'compress'. GIF modifications by\n  David Rowley (mgardi@watdcsu.waterloo.edu)\n  GIF Image compression - modified 'compress'\n  Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  Jim McKie (decvax!mcvax!jim)\n  Steve Davies (decvax!vax135!petsd!peora!srd)\n  Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  James A. Woods (decvax!ihnp4!ames!jaw)\n  Joe Orost (decvax!vax135!petsd!joe)\n*/\nvar remaining,\n    curPixel,\n    n_bits,\n    EOF = -1,\n    BITS = 12,\n    HSIZE = 5003,\n    // 80% occupancy\nmasks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\nfunction LZWEncoder(width, height, pixels, colorDepth) {\n\tvar initCodeSize = Math.max(2, colorDepth),\n\t    accum = new Uint8Array(256),\n\t    htab = new Int32Array(HSIZE),\n\t    codetab = new Int32Array(HSIZE),\n\t    cur_accum,\n\t    cur_bits = 0,\n\t    a_count,\n\t    free_ent = 0,\n\t    // first unused entry\n\tmaxcode,\n\n\n\t// block compression parameters -- after all codes are used up,\n\t// and compression rate changes, start over.\n\tclear_flg = false,\n\n\n\t// Algorithm: use open addressing double hashing (no chaining) on the\n\t// prefix code / next character combination. We do a variant of Knuth's\n\t// algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n\t// secondary probe. Here, the modular division first probe is gives way\n\t// to a faster exclusive-or manipulation. Also do block compression with\n\t// an adaptive reset, whereby the code table is cleared when the compression\n\t// ratio decreases, but after the table fills. The variable-length output\n\t// codes are re-sized at this point, and a special CLEAR code is generated\n\t// for the decompressor. Late addition: construct the table according to\n\t// file size for noticeable speed improvement on small files. Please direct\n\t// questions about this implementation to ames!jaw.\n\tg_init_bits,\n\t    ClearCode,\n\t    EOFCode;\n\n\t// Add a character to the end of the current packet, and if it is 254\n\t// characters, flush the packet to disk.\n\tfunction char_out(c, outs) {\n\t\taccum[a_count++] = c;\n\t\tif (a_count >= 254) {\n\t\t\tflush_char(outs);\n\t\t}\n\t}\n\n\t// Clear out the hash table\n\t// table clear for block compress\n\tfunction cl_block(outs) {\n\t\tcl_hash(HSIZE);\n\t\tfree_ent = ClearCode + 2;\n\t\tclear_flg = true;\n\t\toutput(ClearCode, outs);\n\t}\n\n\t// Reset code table\n\tfunction cl_hash(hsize) {\n\t\tfor (var i = 0; i < hsize; ++i) {\n\t\t\thtab[i] = -1;\n\t\t}\n\t}\n\n\tfunction compress(init_bits, outs) {\n\t\tvar fcode, c, i, ent, disp, hsize_reg, hshift;\n\n\t\t// Set up the globals: g_init_bits - initial number of bits\n\t\tg_init_bits = init_bits;\n\n\t\t// Set up the necessary values\n\t\tclear_flg = false;\n\t\tn_bits = g_init_bits;\n\t\tmaxcode = MAXCODE(n_bits);\n\n\t\tClearCode = 1 << init_bits - 1;\n\t\tEOFCode = ClearCode + 1;\n\t\tfree_ent = ClearCode + 2;\n\n\t\ta_count = 0; // clear packet\n\n\t\tent = nextPixel();\n\n\t\thshift = 0;\n\t\tfor (fcode = HSIZE; fcode < 65536; fcode *= 2) {\n\t\t\t++hshift;\n\t\t}\n\t\thshift = 8 - hshift; // set hash code range bound\n\t\thsize_reg = HSIZE;\n\t\tcl_hash(hsize_reg); // clear hash table\n\n\t\toutput(ClearCode, outs);\n\n\t\touter_loop: while ((c = nextPixel()) != EOF) {\n\t\t\tfcode = (c << BITS) + ent;\n\t\t\ti = c << hshift ^ ent; // xor hashing\n\t\t\tif (htab[i] === fcode) {\n\t\t\t\tent = codetab[i];\n\t\t\t\tcontinue;\n\t\t\t} else if (htab[i] >= 0) {\n\t\t\t\t// non-empty slot\n\t\t\t\tdisp = hsize_reg - i; // secondary hash (after G. Knott)\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tdisp = 1;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tif ((i -= disp) < 0) {\n\t\t\t\t\t\ti += hsize_reg;\n\t\t\t\t\t}\n\t\t\t\t\tif (htab[i] === fcode) {\n\t\t\t\t\t\tent = codetab[i];\n\t\t\t\t\t\tcontinue outer_loop;\n\t\t\t\t\t}\n\t\t\t\t} while (htab[i] >= 0);\n\t\t\t}\n\t\t\toutput(ent, outs);\n\t\t\tent = c;\n\t\t\tif (free_ent < 1 << BITS) {\n\t\t\t\tcodetab[i] = free_ent++; // code -> hashtable\n\t\t\t\thtab[i] = fcode;\n\t\t\t} else {\n\t\t\t\tcl_block(outs);\n\t\t\t}\n\t\t}\n\n\t\t// Put out the final code.\n\t\toutput(ent, outs);\n\t\toutput(EOFCode, outs);\n\t}\n\n\tfunction encode(outs) {\n\t\touts.writeByte(initCodeSize); // write \"initial code size\" byte\n\t\tremaining = width * height; // reset navigation variables\n\t\tcurPixel = 0;\n\t\tcompress(initCodeSize + 1, outs); // compress and write the pixel data\n\t\touts.writeByte(0); // write block terminator\n\t}\n\n\t// Flush the packet to disk, and reset the accumulator\n\tfunction flush_char(outs) {\n\t\tif (a_count > 0) {\n\t\t\touts.writeByte(a_count);\n\t\t\touts.writeBytes(accum, 0, a_count);\n\t\t\ta_count = 0;\n\t\t}\n\t}\n\n\tfunction MAXCODE(n_bits) {\n\t\treturn (1 << n_bits) - 1;\n\t}\n\n\t// Return the next pixel from the image\n\tfunction nextPixel() {\n\t\tif (remaining === 0) {\n\t\t\treturn EOF;\n\t\t}\n\t\t--remaining;\n\t\tvar pix = pixels[curPixel++];\n\t\treturn pix & 0xff;\n\t}\n\n\tfunction output(code, outs) {\n\t\tcur_accum &= masks[cur_bits];\n\n\t\tif (cur_bits > 0) {\n\t\t\tcur_accum |= code << cur_bits;\n\t\t} else {\n\t\t\tcur_accum = code;\n\t\t}\n\n\t\tcur_bits += n_bits;\n\n\t\twhile (cur_bits >= 8) {\n\t\t\tchar_out(cur_accum & 0xff, outs);\n\t\t\tcur_accum >>= 8;\n\t\t\tcur_bits -= 8;\n\t\t}\n\n\t\t// If the next entry is going to be too big for the code size,\n\t\t// then increase it, if possible.\n\t\tif (free_ent > maxcode || clear_flg) {\n\t\t\tif (clear_flg) {\n\t\t\t\tmaxcode = MAXCODE(n_bits = g_init_bits);\n\t\t\t\tclear_flg = false;\n\t\t\t} else {\n\t\t\t\t++n_bits;\n\t\t\t\tif (n_bits == BITS) {\n\t\t\t\t\tmaxcode = 1 << BITS;\n\t\t\t\t} else {\n\t\t\t\t\tmaxcode = MAXCODE(n_bits);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (code == EOFCode) {\n\t\t\t// At EOF, write the rest of the buffer.\n\t\t\twhile (cur_bits > 0) {\n\t\t\t\tchar_out(cur_accum & 0xff, outs);\n\t\t\t\tcur_accum >>= 8;\n\t\t\t\tcur_bits -= 8;\n\t\t\t}\n\t\t\tflush_char(outs);\n\t\t}\n\t}\n\n\tthis.encode = encode;\n}\n\nmodule.exports = LZWEncoder;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/client/libs/gif/LZWEncoder.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/client/libs/gif/LZWEncoder.js?");

/***/ }
/******/ ]);